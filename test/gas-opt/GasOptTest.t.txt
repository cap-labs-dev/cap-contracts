// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import { AccessControl } from "../../contracts/access/AccessControl.sol";
import { IOracle } from "../../contracts/interfaces/IOracle.sol";
import { IStakedCap } from "../../contracts/interfaces/IStakedCap.sol";
import { Lender } from "../../contracts/lendingPool/Lender.sol";
import { InterestDebtToken } from "../../contracts/lendingPool/tokens/InterestDebtToken.sol";
import { PrincipalDebtToken } from "../../contracts/lendingPool/tokens/PrincipalDebtToken.sol";
import { RestakerDebtToken } from "../../contracts/lendingPool/tokens/RestakerDebtToken.sol";
import { Oracle } from "../../contracts/oracle/Oracle.sol";
import { AaveAdapter } from "../../contracts/oracle/libraries/AaveAdapter.sol";
import { CapTokenAdapter } from "../../contracts/oracle/libraries/CapTokenAdapter.sol";
import { ChainlinkAdapter } from "../../contracts/oracle/libraries/ChainlinkAdapter.sol";
import { StakedCapAdapter } from "../../contracts/oracle/libraries/StakedCapAdapter.sol";
import { CapToken } from "../../contracts/token/CapToken.sol";
import { StakedCap } from "../../contracts/token/StakedCap.sol";
import { VaultUpgradeable } from "../../contracts/vault/VaultUpgradeable.sol";
import { MockAaveDataProvider } from "../mocks/MockAaveDataProvider.sol";
import { MockChainlinkPriceFeed } from "../mocks/MockChainlinkPriceFeed.sol";
import { MockDelegation } from "../mocks/MockDelegation.sol";
import { MockERC20 } from "../mocks/MockERC20.sol";
import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Test } from "forge-std/Test.sol";
import { console } from "forge-std/console.sol";

contract GasOptTest is Test {
    // external contract mocks
    MockAaveDataProvider public usdtAaveDataProvider;
    MockAaveDataProvider public usdcAaveDataProvider;
    MockAaveDataProvider public usdxAaveDataProvider;
    MockChainlinkPriceFeed public usdtChainlinkPriceFeed;
    MockChainlinkPriceFeed public usdcChainlinkPriceFeed;
    MockChainlinkPriceFeed public usdxChainlinkPriceFeed;
    MockDelegation public delegation;
    MockERC20 public usdt;
    MockERC20 public usdc;
    MockERC20 public usdx;

    // cap implementations
    AccessControl public accessControlImplementation;
    Lender public lenderImplementation;
    CapToken public capTokenImplementation;
    StakedCap public stakedCapImplementation;
    PrincipalDebtToken public principalDebtTokenImplementation;
    InterestDebtToken public interestDebtTokenImplementation;
    RestakerDebtToken public restakerDebtTokenImplementation;
    Oracle public oracleImplementation;

    // cap instances
    AccessControl public accessControl;
    Lender public lender;
    CapToken public cUSD;
    StakedCap public scUSD;
    Oracle public oracle;
    address public aaveAdapter;
    address public chainlinkAdapter;
    address public capTokenAdapter;
    address public stakedCapAdapter;
    PrincipalDebtToken public usdtPrincipalDebtToken;
    PrincipalDebtToken public usdcPrincipalDebtToken;
    PrincipalDebtToken public usdxPrincipalDebtToken;
    RestakerDebtToken public usdtRestakerDebtToken;
    RestakerDebtToken public usdcRestakerDebtToken;
    RestakerDebtToken public usdxRestakerDebtToken;
    InterestDebtToken public usdtInterestDebtToken;
    InterestDebtToken public usdcInterestDebtToken;
    InterestDebtToken public usdxInterestDebtToken;

    address public user_deployer;
    address public user_agent;
    address public user_stablecoin_minter;
    address public user_liquidator;

    address public user_access_control_admin;
    address public user_address_provider_admin;
    address public user_interest_receiver;
    address public user_vault_keeper;
    address public user_oracle_admin;
    address public user_rate_oracle_admin;
    address public user_vault_config_admin;
    address public user_vaults_admin;
    address public user_lender_admin;

    function setUp() public {
        _setUp();
    }

    function _setUp() public {
        // Setup addresses with gas
        {
            vm.startPrank(user_deployer);
            user_deployer = makeAddr("deployer");
            user_agent = makeAddr("agent");
            user_stablecoin_minter = makeAddr("stablecoin_minter");
            user_liquidator = makeAddr("liquidator");
            user_access_control_admin = makeAddr("access_control_admin");
            user_address_provider_admin = makeAddr("address_provider_admin");
            user_interest_receiver = makeAddr("interest_receiver");
            user_vault_keeper = makeAddr("vault_keeper");
            user_oracle_admin = makeAddr("user_oracle_admin");
            user_rate_oracle_admin = makeAddr("user_rate_oracle_admin");
            user_vault_config_admin = makeAddr("user_vault_config_admin");
            user_lender_admin = makeAddr("user_lender_admin");
            user_vaults_admin = makeAddr("user_vaults_admin");
            // Give gas to all users
            vm.deal(user_deployer, 100 ether);
            vm.deal(user_agent, 100 ether);
            vm.deal(user_stablecoin_minter, 100 ether);
            vm.deal(user_liquidator, 100 ether);
            vm.deal(user_access_control_admin, 100 ether);
            vm.deal(user_address_provider_admin, 100 ether);
            vm.deal(user_interest_receiver, 100 ether);
            vm.deal(user_vault_keeper, 100 ether);
            vm.deal(user_oracle_admin, 100 ether);
            vm.deal(user_rate_oracle_admin, 100 ether);
            vm.deal(user_lender_admin, 100 ether);
            vm.deal(user_vault_config_admin, 100 ether);
            vm.deal(user_vaults_admin, 100 ether);
            vm.stopPrank();
        }

        // Deploy mock tokens
        {
            vm.startPrank(user_deployer);

            usdt = new MockERC20("USDT", "USDT");
            usdc = new MockERC20("USDC", "USDC");
            usdx = new MockERC20("USDx", "USDx");

            // Mint tokens to minter
            usdt.mint(user_stablecoin_minter, 1_000_000e18);
            usdc.mint(user_stablecoin_minter, 1_000_000e18);
            usdx.mint(user_stablecoin_minter, 1_000_000e18);

            // mint some tokens to the liquidator for repayments
            usdt.mint(user_liquidator, 1000e18);
            usdc.mint(user_liquidator, 1000e18);
            usdx.mint(user_liquidator, 1000e18);

            vm.stopPrank();
        }

        // deploy implementations and contracts
        {
            vm.startPrank(user_deployer);

            accessControlImplementation = new AccessControl();
            lenderImplementation = new Lender();
            capTokenImplementation = new CapToken();
            stakedCapImplementation = new StakedCap();
            oracleImplementation = new Oracle();
            principalDebtTokenImplementation = new PrincipalDebtToken();
            interestDebtTokenImplementation = new InterestDebtToken();
            restakerDebtTokenImplementation = new RestakerDebtToken();

            // grab libraries addresses
            aaveAdapter = address(AaveAdapter);
            chainlinkAdapter = address(ChainlinkAdapter);
            capTokenAdapter = address(CapTokenAdapter);
            stakedCapAdapter = address(StakedCapAdapter);

            // Deploy mock data providers
            usdtAaveDataProvider = new MockAaveDataProvider();
            usdcAaveDataProvider = new MockAaveDataProvider();
            usdxAaveDataProvider = new MockAaveDataProvider();
            usdtChainlinkPriceFeed = new MockChainlinkPriceFeed();
            usdcChainlinkPriceFeed = new MockChainlinkPriceFeed();
            usdxChainlinkPriceFeed = new MockChainlinkPriceFeed();
            delegation = new MockDelegation();

            // deploy proxy contracts
            accessControl = AccessControl(_proxy(address(accessControlImplementation)));
            lender = Lender(_proxy(address(lenderImplementation)));
            oracle = Oracle(_proxy(address(oracleImplementation)));

            // init infra instances
            accessControl.initialize(user_access_control_admin);
            lender.initialize(address(accessControl), address(delegation), address(oracle));
            oracle.initialize(address(accessControl));

            // deploy and init cap instances
            cUSD = CapToken(_proxy(address(capTokenImplementation)));
            scUSD = StakedCap(_proxy(address(stakedCapImplementation)));

            address[] memory assets = new address[](3);
            assets[0] = address(usdt);
            assets[1] = address(usdc);
            assets[2] = address(usdx);

            cUSD.initialize("Capped USD", "cUSD", address(accessControl), address(oracle), assets);
            scUSD.initialize(address(accessControl), address(cUSD), 6 hours);

            // deploy and init debt tokens
            usdcPrincipalDebtToken = PrincipalDebtToken(_proxy(address(principalDebtTokenImplementation)));
            usdxPrincipalDebtToken = PrincipalDebtToken(_proxy(address(principalDebtTokenImplementation)));
            usdtPrincipalDebtToken = PrincipalDebtToken(_proxy(address(principalDebtTokenImplementation)));

            usdtRestakerDebtToken = RestakerDebtToken(_proxy(address(restakerDebtTokenImplementation)));
            usdcRestakerDebtToken = RestakerDebtToken(_proxy(address(restakerDebtTokenImplementation)));
            usdxRestakerDebtToken = RestakerDebtToken(_proxy(address(restakerDebtTokenImplementation)));

            usdcInterestDebtToken = InterestDebtToken(_proxy(address(interestDebtTokenImplementation)));
            usdtInterestDebtToken = InterestDebtToken(_proxy(address(interestDebtTokenImplementation)));
            usdxInterestDebtToken = InterestDebtToken(_proxy(address(interestDebtTokenImplementation)));

            usdcPrincipalDebtToken.initialize(address(accessControl), address(usdc));
            usdtPrincipalDebtToken.initialize(address(accessControl), address(usdt));
            usdxPrincipalDebtToken.initialize(address(accessControl), address(usdx));

            usdcRestakerDebtToken.initialize(
                address(accessControl), address(oracle), address(usdcPrincipalDebtToken), address(usdc)
            );
            usdtRestakerDebtToken.initialize(
                address(accessControl), address(oracle), address(usdtPrincipalDebtToken), address(usdt)
            );
            usdxRestakerDebtToken.initialize(
                address(accessControl), address(oracle), address(usdxPrincipalDebtToken), address(usdx)
            );

            usdcInterestDebtToken.initialize(
                address(accessControl), address(oracle), address(usdcPrincipalDebtToken), address(usdc)
            );
            usdtInterestDebtToken.initialize(
                address(accessControl), address(oracle), address(usdtPrincipalDebtToken), address(usdt)
            );
            usdxInterestDebtToken.initialize(
                address(accessControl), address(oracle), address(usdxPrincipalDebtToken), address(usdx)
            );

            vm.stopPrank();
        }

        // Setup access control roles
        {
            vm.startPrank(user_access_control_admin);

            accessControl.grantAccess(IOracle.setPriceOracleData.selector, address(oracle), user_oracle_admin);
            accessControl.grantAccess(IOracle.setPriceBackupOracleData.selector, address(oracle), user_oracle_admin);
            accessControl.grantAccess(IOracle.setRateOracleData.selector, address(oracle), user_oracle_admin);

            accessControl.grantAccess(IOracle.setPriceOracleData.selector, address(oracle), user_rate_oracle_admin);
            accessControl.grantAccess(IOracle.setBenchmarkRate.selector, address(oracle), user_rate_oracle_admin);
            accessControl.grantAccess(IOracle.setRestakerRate.selector, address(oracle), user_rate_oracle_admin);

            accessControl.grantAccess(Lender.addAsset.selector, address(lender), user_lender_admin);
            accessControl.grantAccess(Lender.removeAsset.selector, address(lender), user_lender_admin);
            accessControl.grantAccess(Lender.pauseAsset.selector, address(lender), user_lender_admin);

            accessControl.grantAccess(VaultUpgradeable.borrow.selector, address(cUSD), address(lender));
            accessControl.grantAccess(VaultUpgradeable.repay.selector, address(cUSD), address(lender));

            vm.stopPrank();
        }

        // Setup oracle for assets (usdt, usdc, usdx)
        {
            vm.startPrank(user_oracle_admin);

            // assets price oracle data
            usdtChainlinkPriceFeed.setDecimals(8);
            usdcChainlinkPriceFeed.setDecimals(8);
            usdxChainlinkPriceFeed.setDecimals(8);
            usdtChainlinkPriceFeed.setLatestAnswer(1e8); // $1.00 with 8 decimals
            usdcChainlinkPriceFeed.setLatestAnswer(1e8); // $1.00 with 8 decimals
            usdxChainlinkPriceFeed.setLatestAnswer(1e8); // $1.00 with 8 decimals

            // assets rate oracle data
            usdtAaveDataProvider.setVariableBorrowRate(1e17); // 10% APY, 1e18 = 100%
            usdcAaveDataProvider.setVariableBorrowRate(1e17); // 10% APY, 1e18 = 100%
            usdxAaveDataProvider.setVariableBorrowRate(1e17); // 10% APY, 1e18 = 100%

            // cUSD price oracle data
            IOracle.OracleData memory usdtOracleData = IOracle.OracleData({
                adapter: address(chainlinkAdapter),
                payload: abi.encodeWithSelector(ChainlinkAdapter.price.selector, address(usdtChainlinkPriceFeed))
            });
            IOracle.OracleData memory usdcOracleData = IOracle.OracleData({
                adapter: address(chainlinkAdapter),
                payload: abi.encodeWithSelector(ChainlinkAdapter.price.selector, address(usdcChainlinkPriceFeed))
            });
            IOracle.OracleData memory usdxOracleData = IOracle.OracleData({
                adapter: address(chainlinkAdapter),
                payload: abi.encodeWithSelector(ChainlinkAdapter.price.selector, address(usdxChainlinkPriceFeed))
            });
            oracle.setPriceOracleData(address(usdt), usdtOracleData);
            oracle.setPriceOracleData(address(usdc), usdcOracleData);
            oracle.setPriceOracleData(address(usdx), usdxOracleData);
            oracle.setPriceBackupOracleData(address(usdt), usdtOracleData);
            oracle.setPriceBackupOracleData(address(usdc), usdcOracleData);
            oracle.setPriceBackupOracleData(address(usdx), usdxOracleData);

            // cUSD rate oracle data

            IOracle.OracleData memory usdtRateData = IOracle.OracleData({
                adapter: address(aaveAdapter),
                payload: abi.encodeWithSelector(AaveAdapter.rate.selector, address(usdtAaveDataProvider), address(usdt))
            });
            IOracle.OracleData memory usdcRateData = IOracle.OracleData({
                adapter: address(aaveAdapter),
                payload: abi.encodeWithSelector(AaveAdapter.rate.selector, address(usdcAaveDataProvider), address(usdc))
            });
            IOracle.OracleData memory usdxRateData = IOracle.OracleData({
                adapter: address(aaveAdapter),
                payload: abi.encodeWithSelector(AaveAdapter.rate.selector, address(usdxAaveDataProvider), address(usdx))
            });
            oracle.setRateOracleData(address(usdt), usdtRateData);
            oracle.setRateOracleData(address(usdc), usdcRateData);
            oracle.setRateOracleData(address(usdx), usdxRateData);

            // cUSD and scUSD price oracle data
            IOracle.OracleData memory cUSDOracleData = IOracle.OracleData({
                adapter: address(capTokenAdapter),
                payload: abi.encodeWithSelector(CapTokenAdapter.price.selector, address(cUSD))
            });
            IOracle.OracleData memory scUSDOracleData = IOracle.OracleData({
                adapter: address(stakedCapAdapter),
                payload: abi.encodeWithSelector(StakedCapAdapter.price.selector, address(scUSD))
            });
            oracle.setPriceOracleData(address(cUSD), cUSDOracleData);
            oracle.setPriceOracleData(address(scUSD), scUSDOracleData);
            oracle.setPriceBackupOracleData(address(cUSD), cUSDOracleData);
            oracle.setPriceBackupOracleData(address(scUSD), scUSDOracleData);

            vm.stopPrank();
        }

        // configure lender access control
        {
            vm.startPrank(user_access_control_admin);

            accessControl.grantAccess(Lender.addAsset.selector, address(lender), address(user_lender_admin));
            accessControl.grantAccess(Lender.removeAsset.selector, address(lender), address(user_lender_admin));

            accessControl.grantAccess(Lender.borrow.selector, address(lender), address(user_lender_admin));
            accessControl.grantAccess(Lender.repay.selector, address(lender), address(user_lender_admin));

            accessControl.grantAccess(Lender.liquidate.selector, address(lender), address(user_lender_admin));
            accessControl.grantAccess(Lender.pauseAsset.selector, address(lender), address(user_lender_admin));

            bytes4[] memory selectors = new bytes4[](4);
            selectors[0] = PrincipalDebtToken.mint.selector;
            selectors[1] = PrincipalDebtToken.burn.selector;
            selectors[2] = RestakerDebtToken.burn.selector;
            selectors[3] = InterestDebtToken.burn.selector;

            address[] memory addresses = new address[](3);
            addresses[0] = address(usdcPrincipalDebtToken);
            addresses[1] = address(usdtPrincipalDebtToken);
            addresses[2] = address(usdxPrincipalDebtToken);

            for (uint256 i = 0; i < selectors.length; i++) {
                for (uint256 j = 0; j < addresses.length; j++) {
                    accessControl.grantAccess(selectors[i], addresses[j], address(lender));
                }
            }

            vm.stopPrank();
        }

        // allow agents to borrow any assets
        {
            vm.startPrank(user_lender_admin);

            lender.addAsset(
                address(usdc),
                address(cUSD),
                address(usdcPrincipalDebtToken),
                address(usdcRestakerDebtToken),
                address(usdcInterestDebtToken),
                address(user_interest_receiver),
                1e18
            );

            lender.addAsset(
                address(usdt),
                address(cUSD),
                address(usdtPrincipalDebtToken),
                address(usdtRestakerDebtToken),
                address(usdtInterestDebtToken),
                address(user_interest_receiver),
                1e18
            );

            lender.addAsset(
                address(usdx),
                address(cUSD),
                address(usdxPrincipalDebtToken),
                address(usdxRestakerDebtToken),
                address(usdxInterestDebtToken),
                address(user_interest_receiver),
                1e18
            );

            vm.stopPrank();
        }

        // make the agent covered
        {
            vm.startPrank(user_lender_admin);

            delegation.setCoverage(user_agent, 100000e18);
            delegation.setLtv(user_agent, 1e18);

            vm.stopPrank();
        }

        // init the vault with some assets
        {
            vm.startPrank(user_stablecoin_minter);
            usdc.approve(address(cUSD), 4000e18);
            cUSD.mint(address(usdc), 4000e18, 0, user_stablecoin_minter, block.timestamp + 1 hours);
            usdt.approve(address(cUSD), 4000e18);
            cUSD.mint(address(usdt), 4000e18, 0, user_stablecoin_minter, block.timestamp + 1 hours);
            usdx.approve(address(cUSD), 4000e18);
            cUSD.mint(address(usdx), 4000e18, 0, user_stablecoin_minter, block.timestamp + 1 hours);

            console.log("cUSD balance", cUSD.balanceOf(user_stablecoin_minter));
            cUSD.transfer(address(0xDead), cUSD.balanceOf(user_stablecoin_minter));
            vm.stopPrank();
        }
    }

    function testEmpty() public {
        // empty test to know how much gas is used by the setup() function
    }

    function testMintWithUSDT() public {
        vm.startPrank(user_stablecoin_minter);

        uint256 backingBefore = usdt.balanceOf(address(cUSD));

        // Approve USDT spending
        usdt.approve(address(cUSD), 100e18);

        // Mint cUSD with USDT
        uint256 amountIn = 100e18;
        uint256 minAmountOut = 95e18; // Accounting for potential fees
        uint256 deadline = block.timestamp + 1 hours;

        cUSD.mint(address(usdt), amountIn, minAmountOut, user_stablecoin_minter, deadline);

        // Assert the minting was successful
        assertGt(cUSD.balanceOf(user_stablecoin_minter), 0, "Should have received cUSD tokens");
        assertEq(usdt.balanceOf(address(cUSD)), backingBefore + amountIn, "Vault should have received USDT");

        vm.stopPrank();
    }

    function testMintWithDifferentPrices() public {
        vm.startPrank(user_stablecoin_minter);

        uint256 backingBefore = usdt.balanceOf(address(cUSD));

        // Set USDT price to 1.02 USD
        usdtChainlinkPriceFeed.setLatestAnswer(102e8);

        // Approve USDT spending
        usdt.approve(address(cUSD), 100e18);

        // Mint cUSD with USDT
        uint256 amountIn = 100e18;
        uint256 minAmountOut = 90e18;
        uint256 deadline = block.timestamp + 1 hours;

        cUSD.mint(address(usdt), amountIn, minAmountOut, user_stablecoin_minter, deadline);

        // We should receive less cUSD since USDT is worth more
        assertGe(
            cUSD.balanceOf(user_stablecoin_minter),
            amountIn * 98 / 100,
            "Should have received less cUSD due to higher USDT price"
        );
        assertEq(usdt.balanceOf(address(cUSD)), backingBefore + amountIn, "Vault should have received USDT");

        vm.stopPrank();
    }

    function testMintAndBurn() public {
        vm.startPrank(user_stablecoin_minter);

        // Initial balances
        uint256 initialUsdtBalance = usdt.balanceOf(user_stablecoin_minter);
        uint256 backingBefore = usdt.balanceOf(address(cUSD));

        // First mint cUSD with USDT
        uint256 amountIn = 100e18;
        uint256 minAmountOut = 95e18;
        uint256 deadline = block.timestamp + 1 hours;

        // Approve and mint
        usdt.approve(address(cUSD), amountIn);
        cUSD.mint(address(usdt), amountIn, minAmountOut, user_stablecoin_minter, deadline);

        uint256 mintedAmount = cUSD.balanceOf(user_stablecoin_minter);
        assertGt(mintedAmount, 0, "Should have received cUSD tokens");
        assertEq(usdt.balanceOf(address(cUSD)), backingBefore + amountIn, "Vault should have received USDT");

        // Now burn the cUSD tokens
        uint256 burnAmount = mintedAmount;
        uint256 minOutputAmount = burnAmount * 95e18 / 100e18; // Expect at least 95% back accounting for potential fees

        cUSD.burn(address(usdt), burnAmount, minOutputAmount, user_stablecoin_minter, deadline);

        // Verify final balances
        assertEq(cUSD.balanceOf(user_stablecoin_minter), 0, "Should have burned all cUSD tokens");
        assertGt(
            usdt.balanceOf(user_stablecoin_minter),
            initialUsdtBalance - amountIn + minOutputAmount,
            "Should have received USDT back"
        );

        vm.stopPrank();
    }

    function testMintStakeUnstakeBurn() public {
        vm.startPrank(user_stablecoin_minter);

        // Initial balances
        uint256 initialUsdtBalance = usdt.balanceOf(user_stablecoin_minter);
        uint256 backingBefore = usdt.balanceOf(address(cUSD));

        // First mint cUSD with USDT
        uint256 amountIn = 100e18;
        uint256 minAmountOut = 95e18;
        uint256 deadline = block.timestamp + 1 hours;

        // Approve and mint
        usdt.approve(address(cUSD), amountIn);
        cUSD.mint(address(usdt), amountIn, minAmountOut, user_stablecoin_minter, deadline);

        uint256 mintedAmount = cUSD.balanceOf(user_stablecoin_minter);
        assertGt(mintedAmount, 0, "Should have received cUSD tokens");
        assertEq(usdt.balanceOf(address(cUSD)), backingBefore + amountIn, "Vault should have received USDT");

        // Now stake the cUSD tokens
        cUSD.approve(address(scUSD), mintedAmount);
        scUSD.deposit(mintedAmount, user_stablecoin_minter);

        uint256 stakedAmount = scUSD.balanceOf(user_stablecoin_minter);
        assertGt(stakedAmount, 0, "Should have staked cUSD tokens");

        // Now unstake the cUSD tokens
        scUSD.withdraw(stakedAmount, user_stablecoin_minter, user_stablecoin_minter);

        uint256 unstakedAmount = cUSD.balanceOf(user_stablecoin_minter);
        assertGt(unstakedAmount, 0, "Should have unstaked cUSD tokens");
        assertEq(scUSD.balanceOf(user_stablecoin_minter), 0, "Should have burned all staked cUSD tokens");

        // Now burn the cUSD tokens
        uint256 burnAmount = mintedAmount;
        uint256 minOutputAmount = burnAmount * 95 / 100; // Expect at least 95% back accounting for potential fees

        cUSD.burn(address(usdt), burnAmount, minOutputAmount, user_stablecoin_minter, deadline);

        // Verify final balances
        assertEq(cUSD.balanceOf(user_stablecoin_minter), 0, "Should have burned all cUSD tokens");
        assertGt(
            usdt.balanceOf(user_stablecoin_minter),
            initialUsdtBalance - amountIn + minOutputAmount,
            "Should have received USDT back"
        );

        vm.stopPrank();
    }

    function testAgentBorrowRepay() public {
        vm.startPrank(user_agent);

        address borrowAsset = address(usdc);
        uint256 borrowAmount = 1e18; // mock usdc has 18 decimals
        address receiver = user_agent;

        uint256 backingBefore = usdc.balanceOf(address(cUSD));

        lender.borrow(borrowAsset, borrowAmount, receiver);
        assertEq(usdc.balanceOf(receiver), borrowAmount);

        //simulate yield
        usdc.mint(user_agent, 1000e18);

        // repay the debt
        uint256 interest = 10;
        usdc.approve(address(lender), borrowAmount + interest);
        lender.repay(borrowAsset, borrowAmount, user_agent);
        assertGe(usdc.balanceOf(address(cUSD)), backingBefore);

        vm.stopPrank();
    }

    function testLiquidation() public {
        address borrowAsset = address(usdc);
        uint256 borrowAmount = 1e18; // mock usdc has 18 decimals
        address receiver = user_agent;

        // borrow some assets
        {
            vm.startPrank(user_agent);
            lender.borrow(borrowAsset, borrowAmount, receiver);
            assertEq(usdc.balanceOf(receiver), borrowAmount);
            vm.stopPrank();
        }

        // simulate a price drop
        {
            vm.startPrank(user_oracle_admin);
            usdtChainlinkPriceFeed.setLatestAnswer(90e8);
            usdcChainlinkPriceFeed.setLatestAnswer(90e8);
            usdxChainlinkPriceFeed.setLatestAnswer(90e8);
            vm.stopPrank();
        }

        // anyone can liquidate the debt
        {
            vm.startPrank(user_liquidator);
            // approve repay amount for liquidation
            usdc.approve(address(lender), borrowAmount);
            uint256 liquidatedAmount = lender.liquidate(user_agent, borrowAsset, borrowAmount);
            assertEq(liquidatedAmount, 100000e18);
            vm.stopPrank();
        }

        vm.stopPrank();
    }

    function testPriceOracle() public {
        uint256 usdtPrice = IOracle(address(oracle)).getPrice(address(usdt));
        assertEq(usdtPrice, 1e8, "USDT price should be $1");
    }

    function testRateOracle() public {
        uint256 usdtRate = IOracle(address(oracle)).marketRate(address(usdt));
        assertEq(usdtRate, 1e17, "USDT borrow rate should be 10%, 1e18 being 100%");
    }

    function testCapAdapters() public {
        uint256 cUSDPrice = IOracle(address(oracle)).getPrice(address(cUSD));
        uint256 scUSDPrice = IOracle(address(oracle)).getPrice(address(scUSD));
        assertApproxEqAbs(cUSDPrice, 1e8, 10, "cUSD price should be $1");
        assertApproxEqAbs(scUSDPrice, 1e8, 10, "scUSD price should be $1");
    }
}
